# 15.1 OOP:概述 P526

## 基类--负责定义在层次关系中所有类共同拥有的成员，

## 派生类--定义各自特有的成员

## 继承 基类 派生类 虚函数 类派生列表 动态绑定又称为运行时绑定 override

**_当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定_**

# 15.2 定义基类和派生类

```cpp
class Quote{
     public:
     Quote()=default;
     Quote(const std::string &book,double sales_price):bookNo(book),price(sales_price){}
    std::string isbn()const {
        retrun bookNo;
    }
    virtual double net_price(std::size_t n)const{
        return n*price;
    }
    virtual ~Quote()=default;//对析构函数进行动态绑定
     private:
     std::string bookNo;//书籍的ISBN 
     protected:
     double price=0;//代表普通状态下不打折的价格
}
```

***基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此***

## 成员函数与继承 P528
成员函数如果没有被声明为virtual 则其解析过程发生在编译时而非运行时，因此不存在调用时到底执行哪个版本的疑问，基类对象调用基类成员函数，派生类对象调用派生类的成员函数。
## 访问控制与继承

# 15.2.2 定义派生类
派生类对象 需要有基类部分和自身部分的概念。
图 15.1 Bulk_quote 对象的概念结构 p530

## 派生类使用基类成员
派生类的作用域嵌套在基类的作用域之内。

## 防止继承的发生
C++11提供了一种防止继承的方法，即在类名后面跟一个关键字 final 


# 15.2.3 类型转换与继承
可以将基类的指针或引用绑定到派生类的对象上。
可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用或指针时，实际上我们不清楚所绑定的真实类型，该对象可能是基类对象，也可能是派生类对象。

## 静态类型与动态类型

基类的指针或引用   的静态类型可能与其动态类型不一致，

## 不存在从基类向派生类的隐式类型转换......
之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。

## ......在对象之间不存在类型转换
当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略掉。


必须清楚的一点是：动态绑定只有当我们通过指针或引用调用虚函数时才会发生。
关键概念：存在继承关系的类型之间的转换原则 P536
要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：
- 从派生类到基类的类型转换只对指针或引用类型有效。
- 基类向派生类不存在隐式类型转换。
- 和任何其它类型一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行，


# 15.3 虚函数
关键概念：C++的多态性
***OOP 的核心思想是多态（polymorphism） 多态性这个词起源自希腊语，其含义是：“多种形式”。我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种形式”而无须在意他们的差异。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。
当我们使用基类指针或引用调用基类中定义的一个函数时，我们并不知道函数真正作用的对象是什么类型。因为它可能是 一个基类对象也可能是一个派生类对象，如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断依据是引用或指针所绑定的对象的真实类型。

另一方面，对非虚函数的调用在编译时进行绑定，类似的，通过对象进行的函数（虚函数或者非虚函数）调用也在编译睡绑定，对象的类型是确定不变的。我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用在编译时绑定到该对象所属类中的函数版本上。

当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用。也只有在这种情况下对像的动态类型才有可能与静态类型不同。

***

继承能继承些什么？继承了所有成员，只是有些需要重写。

