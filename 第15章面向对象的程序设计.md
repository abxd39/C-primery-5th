# 15.1 OOP:概述 P526

## 基类--负责定义在层次关系中所有类共同拥有的成员，

## 派生类--定义各自特有的成员

## 继承 基类 派生类 虚函数 类派生列表 动态绑定又称为运行时绑定 override

**_当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定_**

# 15.2 定义基类和派生类

```cpp
class Quote{
     public:
     Quote()=default;
     Quote(const std::string &book,double sales_price):bookNo(book),price(sales_price){}
    std::string isbn()const {
        retrun bookNo;
    }
    virtual double net_price(std::size_t n)const{
        return n*price;
    }
    virtual ~Quote()=default;//对析构函数进行动态绑定
     private:
     std::string bookNo;//书籍的ISBN 
     protected:
     double price=0;//代表普通状态下不打折的价格
}
```

***基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此***

## 成员函数与继承 P528
成员函数如果没有被声明为virtual 则其解析过程发生在编译时而非运行时，因此不存在调用时到底执行哪个版本的疑问，基类对象调用基类成员函数，派生类对象调用派生类的成员函数。
## 访问控制与继承

# 15.2.2 定义派生类
派生类对象 需要有基类部分和自身部分的概念。
图 15.1 Bulk_quote 对象的概念结构 p530

## 派生类使用基类成员
派生类的作用域嵌套在基类的作用域之内。

## 防止继承的发生
C++11提供了一种防止继承的方法，即在类名后面跟一个关键字 final 


# 15.2.3 类型转换与继承
可以将基类的指针或引用绑定到派生类的对象上。
可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用或指针时，实际上我们不清楚所绑定的真实类型，该对象可能是基类对象，也可能是派生类对象。

## 静态类型与动态类型

基类的指针或引用   的静态类型可能与其动态类型不一致，

## 不存在从基类向派生类的隐式类型转换......
之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。

## ......在对象之间不存在类型转换
当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略掉。




继承能继承些什么？继承了所有成员，只是有些需要重写。

