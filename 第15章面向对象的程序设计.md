# 15.1 OOP:概述 P526

## 基类--负责定义在层次关系中所有类共同拥有的成员，

## 派生类--定义各自特有的成员

## 继承 基类 派生类 虚函数 类派生列表 动态绑定又称为运行时绑定 override

**_当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定_**

# 15.2 定义基类和派生类

```cpp
class Quote{
     public:
     Quote()=default;
     Quote(const std::string &book,double sales_price):bookNo(book),price(sales_price){}
    std::string isbn()const {
        retrun bookNo;
    }
    virtual double net_price(std::size_t n)const{
        return n*price;
    }
    virtual ~Quote()=default;//对析构函数进行动态绑定
     private:
     std::string bookNo;//书籍的ISBN 
     protected:
     double price=0;//代表普通状态下不打折的价格
}
```

***基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此***

## 成员函数与继承 P528
成员函数如果没有被声明为virtual 则其解析过程发生在编译时而非运行时，因此不存在调用时到底执行哪个版本的疑问，基类对象调用基类成员函数，派生类对象调用派生类的成员函数。
## 访问控制与继承

# 15.2.2 定义派生类
派生类对象 需要有基类部分和自身部分的概念。
图 15.1 Bulk_quote 对象的概念结构 p530

## 派生类使用基类成员
派生类的作用域嵌套在基类的作用域之内。

## 防止继承的发生
C++11提供了一种防止继承的方法，即在类名后面跟一个关键字 final 


# 15.2.3 类型转换与继承
可以将基类的指针或引用绑定到派生类的对象上。
可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用或指针时，实际上我们不清楚所绑定的真实类型，该对象可能是基类对象，也可能是派生类对象。

## 静态类型与动态类型

基类的指针或引用   的静态类型可能与其动态类型不一致，

## 不存在从基类向派生类的隐式类型转换......
之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。

## ......在对象之间不存在类型转换
当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略掉。


必须清楚的一点是：动态绑定只有当我们通过指针或引用调用虚函数时才会发生。
[关键概念]：存在继承关系的类型之间的转换原则 P536
要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：
- 从派生类到基类的类型转换只对指针或引用类型有效。
- 基类向派生类不存在隐式类型转换。
- 和任何其它类型一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行，


# 15.3 虚函数
[关键概念]：C++的多态性 
***OOP 的核心思想是多态（polymorphism） 多态性这个词起源自希腊语，其含义是：“多种形式”。我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种形式”而无须在意他们的差异。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。
当我们使用基类指针或引用调用基类中定义的一个函数时，我们并不知道函数真正作用的对象是什么类型。因为它可能是 一个基类对象也可能是一个派生类对象，如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断依据是引用或指针所绑定的对象的真实类型。

另一方面，对非虚函数的调用在编译时进行绑定，类似的，通过对象进行的函数（虚函数或者非虚函数）调用也在编译睡绑定，对象的类型是确定不变的。我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用在编译时绑定到该对象所属类中的函数版本上。

当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用。也只有在这种情况下对像的动态类型才有可能与静态类型不同。


***

## 派生类中的虚函数
基类中的虚函数在派生类中隐含地也是一个虚函数，当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。

## final 和override 说明符
final 用于防止继承
override 用于通知编译器检测是否有重写被修饰的函数，只有基类的虚函数才能被标记。
例如：
```cpp
class Base{
    virtual Hello(){
        std::cout<<"hello Base"<<std::endl;
    }
}
class NoDerived final:pulbic Base,... {
    virtal Hello()override;//如果没有重写，编译时会报错。提前暴露了问题
}

class Bad :NoDerived {}//错误 NoDerived 是final的


```

## 虚函数与默认实惨 
反常，不符合预期。
最佳实践 （Best Practices）
***如果虚函数使用默认实惨吗，则基类和派生类中定义的默认实惨最好一致***P539

## 回避虚函数机制
通常情况下，只有成员函数（或者友元）中的代码才需要水用作用域运算符来回避虚函数机制。
什么时候需要回避虚函数默认机制呢？
如果一个派生类虚函数需要调用基类版本，但是没有使用作用域运算符，则在运行时该调用被解析为对派生类版本的自身调用，从而导致无限递归。P539

# 15.4 抽象基类
含义纯虚函数的类是抽象类
我们不能创建抽象基类的对象

# 15.5 访问控制与继承
## 改变个别成员的可访问性 P545
有时我们需要改变派生类继承的某个名字的访问级别，通过using 声明 可以达到这一目的
```cpp
class Base{
    public:
    std::size_t size()const{
        retun n;
    }
    protected:
    std::size_t n;
};

 //因为是private继承，所以继承而来的成员size和n,在默认情况下是Derived的私有成员，然而使用using 声明改变了这些成员的可访问性。改变之后Derived的用户将可以使用size成员，而Derived派生类将肯能使用n，
class Derived:private Base{
    public:
   
    //保持对象尺寸相关的成员的访问级别
    using Base::size;
    priavte:

    using Base::n;
}

```
因为Dervied  使用了私有继承，所以继承而来的成员 size和n(默认情况下)是Derived的私有成员。
派生类只能为哪些它可以访问的名字提供using声明。
[关键概念]：类的设计与受保护的成员
不考虑继承的话，我们可以认为一个类有两种不同的用户：普通用户和类的实现者。其中普通用户编写的代码使用类的对象，这部分代码只能访问类的公有成员。而类的实现者负责编写成员和友元代码，成员和友元能访问类的公有部分，也能访问类的私有部分。
如果进一步考虑的话就出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明为受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍就不能访问私有成员。
和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及友元访问。对于第一组应该声明为受保护的。这样派生类就能在实现自己功能时使用基类的这些操作和数据，第二组应该声明为私有的。

# 15.6 继承中的类作用域
派生类的作用域位于基类作用域之内，因此派生类中的成员函数可以直接使用基类的成员（像使用自己的成员一样使用基类的成员）。
### 在编译时进行名字查找
### 名字冲突与继承
派生类的成员将隐藏同名的基类成员

### 通过作用域运算符来使用隐藏的成员

```html
<font color=#FF000>关键概念：名字查找与继承</font>
``` 
理解函数调用的解析过程对于理解C++语言中的继承至关重要。假设我们调用p->mem()。 (或者obj.mem()),
则一次执行以下四个步骤：
首先确定 p (或 obj) 的静态类型，即 p 的类型。因为我们调用的是一个成员，所以该类型必须是类类型。

在p(或obj)的静态类型对应的类中查找名为 mem() 的成员。如果找不到，则依次在直接基类中查找直到继承链顶端。如果找遍了该类及基类仍就无法找到，则编译器报错。
如果找到，就执行类型检查（6.1节 P183），以确认对于当前查找的mem,本次调用是否合法。
假设调用合法：
如果mem 是虚函数且我们是通过引用或指针进行调用，则编译器产生的代码将在运行时确定到底运行该函数的那个版本，依据是对象的动态类型。
反之，如果memb不是虚函数或者我们是通过对象（非引用或指针）进行的调用，则编译器将产生一个常规函数调用。


## 一如既往，名字查先于类型检查
如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类中的成员将隐藏基类的同名成员。即使派生类成员和基类成员的***形参列表不一致，基类成员也仍然会被隐藏掉***。

## 覆盖重载的函数 p551

# 15.7 构造函数和拷贝控制

# 15.7.1 虚构函数
如果基类的析构函数不是虚函数，则delete 一个指向派生类对象的基类指针将产生未定义的行为。

### 虚构函数将组织合成移动操作

# 15.7.2 拷贝控制与继承

















继承能继承些什么？继承了所有成员，只是有些需要重写。

