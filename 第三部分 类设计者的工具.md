# 13 拷贝控制

实现拷贝控制操作最困难的地方是首先认知到什么时候需要定义这些操作。
C++ 什么时候需要定义 拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符？
[Ai回答]
在C++中，拷贝构造函数、拷贝赋值运算符、移动构造函数和移动赋值运算符是四个用来管理对象生命周期和资源的特殊成员函数。这些函数的定义取决于对象所管理的资源类型和深浅复制需求。以下是具体适用场景：


拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，析构函数。

# 13.1 拷贝构造函————— 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外的参数都有默认值，则此构造函数是拷贝构造。
```cpp
class Foo {
public:
    Foo();//默认构造
    Foo(const Foo&);//拷贝构造函数
    //....
};

```

拷贝构造在几种情况下都会被隐式地使用。
# 参数和返回值
拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是一个引用类型。如果其参数不是引用类型，则调用永远不会成功。


# 拷贝初始化限制 explicit 关键字
# 编译器可以绕过拷贝构造函数

# 13.1.2 拷贝赋值运算符。拷贝赋值运算符接受一个与其所在类相同类型的参数；
```cpp
Foo& operator=(const Foo&);
```

# 重载赋值运算符

# 13.1.3 析构函数

析构函数完成什么工作，
# 什么时候会调用析构函数 ，无论何时，一个对象被手动销毁或者编译器销毁，就会自动调用其析构函数。
C++ 销毁对象的方式有哪些？
AI 回答
在C++中，销毁对象的方式有多种，取决于对象的类型（静态、自动、动态、全局）和对象的分配方式（栈、堆）

### 总结
销毁对象的方式主要有：
1. 静态和全局对象：程序结束时自动销毁。
2. 自动对象（局部对象）：其作用域结束时自动销毁。
3. 动态对象：使用 `delete` 或 `delete[]` 手动销毁。
4. 智能指针：超出作用域时自动销毁其管理的对象。

每种方式都有其适用场景，选择适用的销毁方式可以有效管理内存资源，避免内存泄漏和不必要的开销。

## 编译器可以略过对拷贝构造函数的调用。P442
AI回答
C++编译器可以略过对拷贝构造函数的调用？什么情况下会发生？

在C++中，编译器可以优化掉一些情况下对拷贝构造函数的调用，这被称为“返回值优化”（Return Value Optimization，RVO）和“命名返回值优化”（Named Return Value Optimization，NRVO）。这些优化是为了提高性能，减少不必要的对象拷贝。以下是一些具体情况：

### 1. 返回值优化（RVO）
当一个函数返回一个临时对象时，编译器可以直接在调用者的内存空间中构造对象，而不是首先在被调用者的空间中构造然后拷贝到调用者的空间中。这样就避免了一次拷贝构造函数的调用。

```cpp
class MyClass {
public:
    MyClass() { std::cout << "Default Constructor" << std::endl; }
    MyClass(const MyClass&) { std::cout << "Copy Constructor" << std::endl; }
};

MyClass createObject() {
    return MyClass();  // 通常这里会触发返回值优化
}

int main() {
    MyClass obj = createObject();  // 不会调用拷贝构造函数
    return 0;
}
```

在上面的代码中，`createObject` 函数返回一个临时对象。在没有优化的情况下，这个临时对象会拷贝到 `main` 函数中的 `obj` 对象中。然而，通过RVO，编译器会直接在 `obj` 的内存空间中构造这个临时对象，从而避免拷贝构造函数的调用。

### 2. 命名返回值优化（NRVO）
当一个函数返回一个命名的局部对象时，编译器可以进行NRVO优化，直接在调用者的内存空间中构造这个命名对象，避免一次额外的拷贝。

```cpp
MyClass createNamedObject() {
    MyClass obj;
    return obj;  // 通常这里会触发命名返回值优化
}

int main() {
    MyClass obj = createNamedObject();  // 不会调用拷贝构造函数
    return 0;
}
```

在上面的代码中，`createNamedObject` 函数返回一个命名的局部对象`obj`。通过NRVO，编译器会直接在 `main` 函数中的 `obj` 的内存空间中构造 `createNamedObject` 函数中的 `obj`，避免拷贝构造函数的调用。

### 总结
RVO和NRVO是编译器优化技术，能显著减少对象的拷贝，从而提高程序的性能。关键点包括：

1. **临时对象返回（RVO）：** 当函数返回一个临时对象时，编译器可以直接在调用者的内存空间中构造该对象，而不是在被调用者的内存空间中构造再拷贝。
2. **命名对象返回（NRVO）：** 当函数返回一个命名局部对象时，编译器可以直接在调用者的内存空间中构造该对象，而不是在被调用者的内存空间中构造再拷贝。

对于这两种优化，C++17标准开始强制要求编译器实现这些优化，也就是编译器必须进行这些优化。这意味着在现代C++编译器和标准下，RVO和NRVO几乎总是会发生，提供更好的性能。

了解这些优化情况，可以帮助开发者编写出更高效的代码，并且在调试性能问题时知道编译器在背后进行了哪些优化。


# 13.1.4 三\五 法则
有三个基本操作可以控制类的拷贝操作：拷贝构造函数，拷贝赋值运算符，和析构函数。

原则一：需要析构函数的类也需要拷贝和赋值操作。
原则二：需要拷贝操作的类也需要赋值操作，反之亦然。


# 13.1.5 使用=default
我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本。当我们在类内用=default 修饰成员的声明时，合成的函数将隐式的声明为inline函数。如果不希望生成inline版本的，需要在类外声明为=default。

# 13.1.6 阻止拷贝

iostream 类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲
unique_ptr不允许拷贝和赋值，


# 定义删除的函数 =delete
与=default 不同=delete 必须出现在函数第一次声明的时候。
另一个与=default不同的地方 我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。

# 析构函数不能是删除的成员。
[Ai回答]
C++删除析构函数的使用场景?
在C++中，析构函数用于清理资源，例如释放动态分配的内存或关闭文件。在某些情况下，删除（显式标记为 `delete`）析构函数的类有其特定的使用场景和目的。以下是一些常见的场景及其具体用例：

### 1. 非堆实例化类 (禁止栈上实例化)
通过删除析构函数，可以防止创建栈上的实例。这种类型通常用于确保对象只能在堆上创建，通过工厂函数或智能指针进行管理。这对于确保对象生命周期的控制是很有帮助的。

```cpp
class NonStackClass {
public:
    ~NonStackClass() = delete;
    // 其他成员函数
};

int main() {
    // NonStackClass obj; // 错误：编译器禁止栈上实例化对象
    NonStackClass* obj = new NonStackClass; // 允许堆上实例化
    delete obj; // 需要手动释放
}
```

### 2. 单例模式
单例模式是一种设计模式，确保一个类只有一个实例。在某些情况下，我们希望单例对象在程序结束时自动销毁，而不需要显式的析构函数。

```cpp
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
    
    ~Singleton() = delete;

private:
    Singleton() {}
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    Singleton& instance = Singleton::getInstance();
    // 使用单例
}
```

### 3. 防止不正确的用法
删除析构函数可以用于防止不希望的或不正确的用法。例如，某些类可能通过配套的资源管理策略（如RAII）管理其生命周期，而不希望用户随意销毁实例，这时候删除析构函数就可以避免错误的内存管理。

```cpp
class ResourceHandler {
public:
    static ResourceHandler& getInstance() {
        static ResourceHandler instance;
        return instance;
    }
    
    ~ResourceHandler() = delete;

private:
    ResourceHandler() {}
    ResourceHandler(const ResourceHandler&) = delete;
    ResourceHandler& operator=(const ResourceHandler&) = delete;
};

int main() {
    ResourceHandler& handler = ResourceHandler::getInstance();
    // 使用资源管理器
}
```

### 总结
删除析构函数的主要目的是限制对象的某些不期望的用法，具体包括但不限于：

1. **非堆实例化类**：防止栈上实例化。
2. **单例模式**：确保只有一个实例并管理它的生命周期。
3. **防止不正确用法**：避免用户随意销毁实例，确保资源管理符合预期。

通过合理使用删除析构函数，可以在某些情况下使代码更健壮，并帮助程序员避免一些常见的错误。
[Ai回答]
C++ 类类型中private 的构造函数的使用场景？

在C++中，将类的构造函数声明为私有或受保护的（即非public的）有多种用途，这种设计主要是为了控制类的实例化方式，确保类的使用符合预期。以下是几个常见的使用场景及其例子：

### 1. 单例模式（Singleton Pattern）
单例模式确保一个类在应用程序中只能有一个实例，并提供一个全局访问点。通过将构造函数声明为私有，可以防止类的实例被外部代码直接创建。

```cpp
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
    
private:
    Singleton() {} // 私有构造函数
    ~Singleton() {}
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    Singleton& instance = Singleton::getInstance();
    // 使用单例对象
}
```

### 2. 工厂模式（Factory Pattern）
工厂模式通过将对象创建过程封装在工厂方法中来实现。这种方式允许类的创建过程更加灵活，并且可以在需要时调整实际创建的类。

```cpp
class MyClass {
private:
    MyClass() {} // 私有构造函数

public:
    static MyClass* createInstance() {
        return new MyClass(); // 工厂方法负责对象创建
    }
};

int main() {
    MyClass* obj = MyClass::createInstance();
    // 使用对象
    delete obj;
}
```

### 3. 禁止实例化
有时候我们需要一个类仅包含静态成员函数和变量，不允许创建实例。通过将构造函数声明为私有，可以防止类被实例化。

```cpp
class Utility {
private:
    Utility() {} // 私有构造函数

public:
    static void doSomething() {
        // 实用函数
    }
};

int main() {
    // Utility util; // 错误：不能实例化
    Utility::doSomething(); // 正确：调用静态方法
}
```

### 4. 通过友元类或函数进行控制
有时我们希望只有特定的类或函数能够实例化这个类对象。通过将构造函数声明为私有，并指定友元类或友元函数，可以实现这一点。

```cpp
class MyClass {
private:
    MyClass() {} // 私有构造函数

    friend class FriendClass; // FriendClass 可以访问私有构造函数

public:
    void display() {
        // 成员函数
    }
};

class FriendClass {
public:
    static MyClass createInstance() {
        return MyClass(); // 友元类可以访问私有构造函数
    }
};

int main() {
    MyClass obj = FriendClass::createInstance();
    obj.display(); // 使用对象
}
```

### 5. 引用计数（Reference Counting）
引用计数机制用于管理对象的生命周期，确保对象在引用计数为零时被正确销毁。通过将构造函数私有化，可以控制对象创建只能通过特定的工厂方法或函数。

```cpp
class RefCounted {
private:
    int refCount;
    RefCounted(): refCount(1) {} // 私有构造函数

public:
    static RefCounted* createInstance() {
        return new RefCounted();
    }

    void addRef() {
        ++refCount;
    }

    void release() {
        if (--refCount == 0) {
            delete this;
        }
    }
};

int main() {
    RefCounted* obj = RefCounted::createInstance();
    obj->addRef();
    obj->release();
    obj->release(); // 最后一次释放时销毁对象
}
```

### 总结
将类的构造函数声明为私有或受保护的主要目的是为了控制对象的创建过程。这种设计可以用于实现单例模式、防止类实例化、使用工厂模式进行对象创建、限制实例化权限等。通过这种方式，可以使类的使用更加安全和可控。

# private 拷贝控制
希望阻止拷贝的类应该使用=delete 来定义它们自己的拷贝构造函数和拷贝赋值元素符，而不应该将它们声明为private的。


# 13.2 拷贝控制和资源管理
通常，管理类外资源的类必须定义拷贝控制成员。

# 13.2.2  定义行为像指针的类型。令一个类展现类似指针的行为最好的方法就是使用shared_ptr 来管理类中的资。
# 如果希望直接管理资源，需要使用引用计数

# 引用计数 引用计数的工作方式（P455）

# 13.3 交换操作（P457）
使用场景
对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。这类算法在需要交换两个元素是会调用swap。

# swap函数应该调用swap，而不是std::swap P458 
# 在赋值元素符中使用swap （P459）
 定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用一种名为[拷贝并交换]（copy and swap）的技术。


