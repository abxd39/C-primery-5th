# 13 拷贝控制

实现拷贝控制操作最困难的地方是首先认知到什么时候需要定义这些操作。
C++ 什么时候需要定义 拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符？
[Ai回答]
在C++中，拷贝构造函数、拷贝赋值运算符、移动构造函数和移动赋值运算符是四个用来管理对象生命周期和资源的特殊成员函数。这些函数的定义取决于对象所管理的资源类型和深浅复制需求。以下是具体适用场景：


拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，析构函数。

# 13.1 拷贝构造函————— 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外的参数都有默认值，则此构造函数是拷贝构造。
```cpp
class Foo {
public:
    Foo();//默认构造
    Foo(const Foo&);//拷贝构造函数
    //....
};

```

拷贝构造在几种情况下都会被隐式地使用。
# 参数和返回值
拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是一个引用类型。如果其参数不是引用类型，则调用永远不会成功。


# 拷贝初始化限制 explicit 关键字
# 编译器可以绕过拷贝构造函数

# 13.1.2 拷贝赋值运算符。拷贝赋值运算符接受一个与其所在类相同类型的参数；
```cpp
Foo& operator=(const Foo&);
```

# 重载赋值运算符

# 13.1.3 析构函数

析构函数完成什么工作，
# 什么时候会调用析构函数 ，无论何时，一个对象被手动销毁或者编译器销毁，就会自动调用其析构函数。
C++ 销毁对象的方式有哪些？
AI 回答
在C++中，销毁对象的方式有多种，取决于对象的类型（静态、自动、动态、全局）和对象的分配方式（栈、堆）

### 总结
销毁对象的方式主要有：
1. 静态和全局对象：程序结束时自动销毁。
2. 自动对象（局部对象）：其作用域结束时自动销毁。
3. 动态对象：使用 `delete` 或 `delete[]` 手动销毁。
4. 智能指针：超出作用域时自动销毁其管理的对象。

每种方式都有其适用场景，选择适用的销毁方式可以有效管理内存资源，避免内存泄漏和不必要的开销。

## 编译器可以略过对拷贝构造函数的调用。P442
AI回答
C++编译器可以略过对拷贝构造函数的调用？什么情况下会发生？

在C++中，编译器可以优化掉一些情况下对拷贝构造函数的调用，这被称为“返回值优化”（Return Value Optimization，RVO）和“命名返回值优化”（Named Return Value Optimization，NRVO）。这些优化是为了提高性能，减少不必要的对象拷贝。以下是一些具体情况：

### 1. 返回值优化（RVO）
当一个函数返回一个临时对象时，编译器可以直接在调用者的内存空间中构造对象，而不是首先在被调用者的空间中构造然后拷贝到调用者的空间中。这样就避免了一次拷贝构造函数的调用。

```cpp
class MyClass {
public:
    MyClass() { std::cout << "Default Constructor" << std::endl; }
    MyClass(const MyClass&) { std::cout << "Copy Constructor" << std::endl; }
};

MyClass createObject() {
    return MyClass();  // 通常这里会触发返回值优化
}

int main() {
    MyClass obj = createObject();  // 不会调用拷贝构造函数
    return 0;
}
```

在上面的代码中，`createObject` 函数返回一个临时对象。在没有优化的情况下，这个临时对象会拷贝到 `main` 函数中的 `obj` 对象中。然而，通过RVO，编译器会直接在 `obj` 的内存空间中构造这个临时对象，从而避免拷贝构造函数的调用。

### 2. 命名返回值优化（NRVO）
当一个函数返回一个命名的局部对象时，编译器可以进行NRVO优化，直接在调用者的内存空间中构造这个命名对象，避免一次额外的拷贝。

```cpp
MyClass createNamedObject() {
    MyClass obj;
    return obj;  // 通常这里会触发命名返回值优化
}

int main() {
    MyClass obj = createNamedObject();  // 不会调用拷贝构造函数
    return 0;
}
```

在上面的代码中，`createNamedObject` 函数返回一个命名的局部对象`obj`。通过NRVO，编译器会直接在 `main` 函数中的 `obj` 的内存空间中构造 `createNamedObject` 函数中的 `obj`，避免拷贝构造函数的调用。

### 总结
RVO和NRVO是编译器优化技术，能显著减少对象的拷贝，从而提高程序的性能。关键点包括：

1. **临时对象返回（RVO）：** 当函数返回一个临时对象时，编译器可以直接在调用者的内存空间中构造该对象，而不是在被调用者的内存空间中构造再拷贝。
2. **命名对象返回（NRVO）：** 当函数返回一个命名局部对象时，编译器可以直接在调用者的内存空间中构造该对象，而不是在被调用者的内存空间中构造再拷贝。

对于这两种优化，C++17标准开始强制要求编译器实现这些优化，也就是编译器必须进行这些优化。这意味着在现代C++编译器和标准下，RVO和NRVO几乎总是会发生，提供更好的性能。

了解这些优化情况，可以帮助开发者编写出更高效的代码，并且在调试性能问题时知道编译器在背后进行了哪些优化。


# 13.1.4 三\五 法则
有三个基本操作可以控制类的拷贝操作：拷贝构造函数，拷贝赋值运算符，和析构函数。

原则一：需要析构函数的类也需要拷贝和赋值操作。
原则二：需要拷贝操作的类也需要赋值操作，反之亦然。


# 13.1.5 使用=default
我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本。当我们在类内用=default 修饰成员的声明时，合成的函数将隐式的声明为inline函数。如果不希望生成inline版本的，需要在类外声明为=default。

# 13.1.6 阻止拷贝

iostream 类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲
unique_ptr不允许拷贝和赋值，


# 定义删除的函数 =delete
与=default 不同=delete 必须出现在函数第一次声明的时候。
另一个与=default不同的地方 我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。

# 析构函数不能是删除的成员。
[Ai回答]
C++删除析构函数的使用场景?
在C++中，析构函数用于清理资源，例如释放动态分配的内存或关闭文件。在某些情况下，删除（显式标记为 `delete`）析构函数的类有其特定的使用场景和目的。以下是一些常见的场景及其具体用例：

### 1. 非堆实例化类 (禁止栈上实例化)
通过删除析构函数，可以防止创建栈上的实例。这种类型通常用于确保对象只能在堆上创建，通过工厂函数或智能指针进行管理。这对于确保对象生命周期的控制是很有帮助的。

```cpp
class NonStackClass {
public:
    ~NonStackClass() = delete;
    // 其他成员函数
};

int main() {
    // NonStackClass obj; // 错误：编译器禁止栈上实例化对象
    NonStackClass* obj = new NonStackClass; // 允许堆上实例化
    delete obj; // 此操作是不允许的。
}
```

### 2. 单例模式
单例模式是一种设计模式，确保一个类只有一个实例。在某些情况下，我们希望单例对象在程序结束时自动销毁，而不需要显式的析构函数。

```cpp
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
    
    ~Singleton() = delete;

private:
    Singleton() {}
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    Singleton& instance = Singleton::getInstance();
    // 使用单例
}
```

### 3. 防止不正确的用法
删除析构函数可以用于防止不希望的或不正确的用法。例如，某些类可能通过配套的资源管理策略（如RAII）管理其生命周期，而不希望用户随意销毁实例，这时候删除析构函数就可以避免错误的内存管理。

```cpp
class ResourceHandler {
public:
    static ResourceHandler& getInstance() {
        static ResourceHandler instance;
        return instance;
    }
    
    ~ResourceHandler() = delete;

private:
    ResourceHandler() {}
    ResourceHandler(const ResourceHandler&) = delete;
    ResourceHandler& operator=(const ResourceHandler&) = delete;
};

int main() {
    ResourceHandler& handler = ResourceHandler::getInstance();
    // 使用资源管理器
}
```

### 总结
删除析构函数的主要目的是限制对象的某些不期望的用法，具体包括但不限于：

1. **非堆实例化类**：防止栈上实例化。
2. **单例模式**：确保只有一个实例并管理它的生命周期。
3. **防止不正确用法**：避免用户随意销毁实例，确保资源管理符合预期。

通过合理使用删除析构函数，可以在某些情况下使代码更健壮，并帮助程序员避免一些常见的错误。
[Ai回答]
C++ 类类型中private 的构造函数的使用场景？

在C++中，将类的构造函数声明为私有或受保护的（即非public的）有多种用途，这种设计主要是为了控制类的实例化方式，确保类的使用符合预期。以下是几个常见的使用场景及其例子：

### 1. 单例模式（Singleton Pattern）
单例模式确保一个类在应用程序中只能有一个实例，并提供一个全局访问点。通过将构造函数声明为私有，可以防止类的实例被外部代码直接创建。

```cpp
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
    
private:
    Singleton() {} // 私有构造函数
    ~Singleton() {}
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    Singleton& instance = Singleton::getInstance();
    // 使用单例对象
}
```

### 2. 工厂模式（Factory Pattern）
工厂模式通过将对象创建过程封装在工厂方法中来实现。这种方式允许类的创建过程更加灵活，并且可以在需要时调整实际创建的类。

```cpp
class MyClass {
private:
    MyClass() {} // 私有构造函数

public:
    static MyClass* createInstance() {
        return new MyClass(); // 工厂方法负责对象创建
    }
};

int main() {
    MyClass* obj = MyClass::createInstance();
    // 使用对象
    delete obj;
}
```

### 3. 禁止实例化
有时候我们需要一个类仅包含静态成员函数和变量，不允许创建实例。通过将构造函数声明为私有，可以防止类被实例化。

```cpp
class Utility {
private:
    Utility() {} // 私有构造函数

public:
    static void doSomething() {
        // 实用函数
    }
};

int main() {
    // Utility util; // 错误：不能实例化
    Utility::doSomething(); // 正确：调用静态方法
}
```

### 4. 通过友元类或函数进行控制
有时我们希望只有特定的类或函数能够实例化这个类对象。通过将构造函数声明为私有，并指定友元类或友元函数，可以实现这一点。

```cpp
class MyClass {
private:
    MyClass() {} // 私有构造函数

    friend class FriendClass; // FriendClass 可以访问私有构造函数

public:
    void display() {
        // 成员函数
    }
};

class FriendClass {
public:
    static MyClass createInstance() {
        return MyClass(); // 友元类可以访问私有构造函数
    }
};

int main() {
    MyClass obj = FriendClass::createInstance();
    obj.display(); // 使用对象
}
```

### 5. 引用计数（Reference Counting）
引用计数机制用于管理对象的生命周期，确保对象在引用计数为零时被正确销毁。通过将构造函数私有化，可以控制对象创建只能通过特定的工厂方法或函数。

```cpp
class RefCounted {
private:
    int refCount;
    RefCounted(): refCount(1) {} // 私有构造函数

public:
    static RefCounted* createInstance() {
        return new RefCounted();
    }

    void addRef() {
        ++refCount;
    }

    void release() {
        if (--refCount == 0) {
            delete this;
        }
    }
};

int main() {
    RefCounted* obj = RefCounted::createInstance();
    obj->addRef();
    obj->release();
    obj->release(); // 最后一次释放时销毁对象
}
```

### 总结
将类的构造函数声明为私有或受保护的主要目的是为了控制对象的创建过程。这种设计可以用于实现单例模式、防止类实例化、使用工厂模式进行对象创建、限制实例化权限等。通过这种方式，可以使类的使用更加安全和可控。

# private 拷贝控制
希望阻止拷贝的类应该使用=delete 来定义它们自己的拷贝构造函数和拷贝赋值元素符，而不应该将它们声明为private的。


# 13.2 拷贝控制和资源管理
通常，管理类外资源的类必须定义拷贝控制成员。

# 13.2.2  定义行为像指针的类型。令一个类展现类似指针的行为最好的方法就是使用shared_ptr 来管理类中的资。
# 如果希望直接管理资源，需要使用引用计数

# 引用计数 引用计数的工作方式（P455）

# 13.3 交换操作（P457）
使用场景
对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。这类算法在需要交换两个元素是会调用swap。

# swap函数应该调用swap，而不是std::swap P458 
# 在赋值元素符中使用swap （P459）
 定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用一种名为[拷贝并交换]（copy and swap）的技术。

# 13.4 拷贝控制示例  
 虽然通常来说分配资源的类更需要拷贝控制，但资源管理并不是一个需要定义自己的拷贝控制成员的唯一原因。
 拷贝赋值运算符通常指向拷贝构造和析构函数中也要做的工作。这种情况，公共的工作应该放在private的中举函数中完成。


 # 13.5 动态内存管理类
  ## 在重新分配内存的过程中移动而不是拷贝元素。
  ## 移动构造函数和std::move
  ## 移动构造函数的工作机制
移动构造函数允许资源所有权从一个对象转移到另一个对象，而不是复制它们。这意味着我们可以避免不必要的内存分配和数据复制，通过简单地转移指针来提高效率。

# 13.6 对象移动
## 新标准的一个最主要的特性是可以移动而非拷贝对象的能力,如我们在13.1.1节 （第440页）中所见，很多情况下都会发生对象拷贝，在其中某些情况下，对象的拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅提升性能，
使用移动而不是拷贝的另一个原因源于IO类和unique_ptr这样的类，这些类都包含不能被共享的资源，（如指针和IO缓冲）。因此这些类型的对象不能拷贝但是可以移动。
对象移动的使用场景：
1、在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。
# 13.6.1 右值引用 P471
一般而言 一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象值。类似任何引用，一个右值引用也不过是某个对象的另一个别名而已。
[右值引用一个重要的性质---只能绑定到一个将要销毁的对象]因此我们可以自由的将一个右值引用的资源""移动"到另一个对象中,移动延长了对象的生命周期。

# 左值持久；右值短暂
右值要么是字面常量，要么是表达式求值过程中创建的临时对象。
由于右值引用只能绑定到临时对象，我们得知：
1、所引用的对象就要销毁
2、该对象没有其他用户
这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象资源。

如何很好的理解左值引用和右值引用？
[AI回答]
理解C++中的左值引用（lvalue references）和右值引用（rvalue references）是掌握C++现代特性的重要一步。下面来详细讲解一下它们的概念、区别以及应用场景。

### 左值引用（Lvalue Reference）

左值引用使用单个 `&` 符号表示，用于引用一个已经存在的对象。左值引用是C++中的经典引用类型。

**特点：**
1. **引用的是持久的对象**：左值引用绑定到一个变量或对象，保证该对象在引用期间始终存在。
2. **用于重用和修改**：可以通过左值引用来修改被引用的对象。

**示例：**
```cpp
int x = 10;
int& ref = x;  // ref 是 x 的左值引用
ref = 20;  // 修改 ref 会改变 x 的值
std::cout << x;  // 输出 20
```

### 右值引用（Rvalue Reference）

右值引用使用 `&&` 符号表示，用于引用一个临时对象或即将被销毁的对象。右值引用是C++11引入的特性，主要用于实现移动语义和完美转发。

**特点：**
1. **引用的是短暂的对象**：右值引用可以绑定到一个临时对象，这个临时对象在使用后即被销毁。
2. **用于转移资源**：可以通过右值引用将资源从一个对象转移到另一个对象，避免了不必要的拷贝。

**示例：**
```cpp
std::string str = "Hello";
std::string&& rref = std::move(str);  // rref 是一个右值引用，引用了 str
std::cout << rref;  // 输出 "Hello"
```

### 左值与右值的区分

- **左值（Lvalue）**：可以取地址的对象，比如变量 `x`、数组元素 `arr[0]`。
- **右值（Rvalue）**：不能取地址的临时对象，比如字面量 `10`、临时对象 `x + y`。

**示例：**
```cpp
int x = 10;
int y = 20;
int* px = &x;  // x 是左值，可以取地址
int* py = &(x + y);  // 编译错误，x + y 是右值，不能取地址
```

### 移动语义与完美转发

右值引用的一个重要应用是在移动语义中，通过移动构造函数和移动赋值运算符来避免不必要的拷贝操作，从而提高性能。

**移动构造函数：**
```cpp
class MyClass {
public:
    MyClass(std::vector<int>&& vec) : vec_(std::move(vec)) {}
    
private:
    std::vector<int> vec_;
};
```

**完美转发：**
```cpp
template<typename T>
void wrapper(T&& arg) {
    process(std::forward<T>(arg));  // 根据 arg 是左值还是右值来选择合适的引用类型
}
```

### 小结

全面理解左值引用和右值引用的关键在于掌握它们的定义、场景以及各自的特性：
- **左值引用**：引用一个持久的对象，适用于需要重用和修改对象的场景。
- **右值引用**：引用一个临时的对象，适用于优化资源移动和转移的场景。

通过实践和不断的代码编写，可以更好地掌握和应用左值引用与右值引用，充分利用C++语言的强大特性。

C++左值右值 是指什么的左边什么的右边？
[AI回答]
左值（Lvalue）：表示一个持久对象，能够出现在赋值操作的左边，可以获取内存地址。
右值（Rvalue）：表示一个临时值，通常出现在赋值操作的右边，不能获取内存地址。


# 标准库 move
```cpp

int &&rr3=std::move(rr1);
```
move 告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。