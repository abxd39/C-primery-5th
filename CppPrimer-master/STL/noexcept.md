C++ 标准库容器在异常发生时提供多种类型的异常安全保障（Exception Safety Guarantee），以确保容器在操作失败时能维持合理的状态。具体的保障机制包括以下几个方面：

### 1. 异常安全保证类型

#### 基本保证（Basic Guarantee）

即保证异常发生后对象仍然是有效状态，即对象的内部数据结构和不变量保持有效。基本保证意味着即使操作失败，程序的状态仍然是一致的，没有资源泄漏。

#### 强保证（Strong Guarantee）

保证异常发生后，程序状态完全回到操作前的状态，即操作具有回滚特性。这意味着如果某个操作失败，所有已完成的部分操作都会被撤销，容器会恢复到操作前的状态。

#### 无抛出保证（No-Throw Guarantee）

操作保证不抛出任何异常。这通常用于基础操作，比如析构函数、交换函数等。

### 2. 容器的异常安全保障机制

不同的容器有相应的异常安全策略，通过多种机制来提供保障。

#### 2.1 `std::vector`

- **操作：`push_back`、`emplace_back`、`insert`等扩容操作**
  - 保障类型：强保证（如果对象的移动构造函数和移动赋值运算符是 noexcept 的），否则是基本保证。
  - 机制：在扩容时，`std::vector` 会分配新的内存，然后尝试将旧元素移动到新内存。如果移动过程中出现异常，则释放新内存，容器仍处于有效状态。

- **操作：`erase`、`pop_back`**
  - 保障类型：强保证（如果对象的析构函数是 noexcept 的），否则是基本保证。
  - 机制：只删除指定元素，并移动后续元素来填补空缺。

#### 2.2 `std::list` 和 `std::forward_list`

- **操作：`insert`、`erase`、`splice` 等**
  - 保障类型：强保证（如果对象的析构函数和复制/移动构造函数是 noexcept 的），否则是基本保证。
  - 机制：基于链表的内存管理方式，使得对于单个元素的插入和删除操作只改变少量指针操作。

#### 2.3 `std::map` 和 `std::set`

- **操作：`insert` 和 `erase`**
  - 保障类型：对于插入强保证（如果键和值的复制/移动构造函数是 noexcept 的），删除操作一般提供基本保证。
  - 机制：基于关联容器的树结构，插入和删除只影响树的一小部分，不会导致整个容器失效。

#### 2.4 `std::unordered_map` 和 `std::unordered_set`

- **操作：`insert`、`erase`、`rehash` 等**
  - 保障类型：强保证（如果键和值的复制/移动构造函数是 noexcept 的），否则是基本保证。
  - 机制：在 rehash 时，如果发生异常，新表会被丢弃，旧表保持原样。

### 3. 实现策略

#### 3.1 拷贝-构造-销毁模式

在涉及到资源管理的操作（如重新分配内存）时，C++ 标准库容器通常采用 "拷贝-构造-销毁" 模式来保证强异常安全性实现：

- **备份当前状态**：在进行可能失败的操作前，先备份当前的状态。
- **尝试操作**：尝试进行操作，如果成功则用新状态替换旧状态。
- **失败回滚**：如果操作中出现异常，自动回滚到备份状态。

#### 3.2 RAII（资源获取即初始化）

通过 RAII 模式，容器使用的资源（如内存）的生命周期与对象的生命周期绑定在一起，确保资源在异常发生时自动释放。

#### 3.3 条件性的`noexcept`

在模板类和泛型算法中，标准库会使用条件性的`noexcept`，以确保必要的异常安全性。比如，许多标准库函数会通过特性检测 (`type traits`) 判断类型的构造/析构/移动操作是否 noexcept，并据此确定操作的异常安全级别。

```cpp
template <typename T>
void MyFunction(T&& x) noexcept(std::is_nothrow_move_constructible<T>::value) {
    T y = std::move(x);
}
```

### 总结

C++ 标准库容器在异常发生时提供不同级别的异常安全保证：基本保证、强保证和无抛出保证。容器通过多种策略（如拷贝-构造-销毁模式、RAII、条件性的`noexcept`判断）实现这些保证，从而确保容器在操作失败时仍能维持合理的状态。这些策略使得使用标准库容器时能够有更高的安全性和鲁棒性。