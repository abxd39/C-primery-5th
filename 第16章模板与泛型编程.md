***当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者公式***
模板类一个很好的例子 就是 ***简历模板、身份证***

泛型编程是一种思想。 模板是用来实现泛型编程的一种方式。  
它允许我们编写可以适用于多种数据类型的代码。通过使用泛型，我们可以编写更加通用和灵活的代码，而不需要为每种数据类型编写重复的代码。     
模板与类的区别

StrBlob 类  
与   
template<T> calss Blob{    
    
}    
不同 我们的模板可以用于更多类型的元素。与标准库容器相同，当使用Blob 时，用户需要指出元素类型。

# 16.1 定义模板 P578
假定我们希望编写一个函数来比较两个值，并指出第一个值是小于，等于还是大于第二个值。在实际中，我们可能像定义多个函数，每个函数比较一种给定的值，
```cpp
//如果两个值相等，返回0，如果v1小 返回-1 如果v2 小返回1

int compare(const string &v1,const string &v2){
    if (v1<v2){
        return -1;
    }
     if (v2<v1){
        return 1;
    }
    return 0;
}


int compare(const double &v1,const double &v2){
    if (v1<v2){
        return -1;
    }
     if (v2<v1){
        return 1;
    }
    return 0;
}

```
两个函数唯一的区别是参数的类型不同。

# 16.1 函数模板
```cpp
template<typename T> 
int compare(const T&v2,const T &v2){
    if (v1<v2){
        return -1;
    }
     if (v2<v1){
        return 1;
    }
    return 0;
}

```

### 在模板定义中， 模板参数列表不能为空。
template<typname T,typename T1....>,参数可以是用逗号分隔的多个。  
*模板参数列表的作用很像函数的参数列表。模板参数表示在类或函数中定义用到的类型或值。（值-->具体的类型）*

### 实例化函数模板
当我们调用一个函数模板时，编译器（通常）用函数实惨来为我们推断模板实惨。  
例如：  
```cpp 
 cout<< compare(1,0)<<endl;//T 为int 
 ``` 

 实惨类型是int ，编译器会推断出模板实惨为int,并将它绑定到模板参数T，
 编译器用推断出来的模板参数来为我们实例化一个特定版本的函数。***

 ### 模板类型参数 P579
 我们的compare 函数有一个模板 类型参数 T，一般来说。我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是。类型参数可以用来指定返回类型。或函数参数类型。以及在函数体捏用于变量声明。或类型转换。
 ```cpp
template <typename T> T foo(T*p){
    T temp=*p;
    //....
    return temp;
}
 ```

 ### 非类型的模板参数
 除了定义类型参数，还可以在模板中定义 非类型参数，一个非类型参数表示一个值而非一个类型。

 比较不同长度的字符串字面量。

 ```cpp
template <unsigned N,unsigned M>
int compare(const char (&p1)[N],const char(&p2)[M]){
    return strcmp(p1,p2);
}
 ```
 ***Note***
 非类型模板参数的模板实惨必须是常量表达式。

 ### inline 和 constexpr 的函数模板

 inline 或constexpr 说明符放在模板参数列表之后，返回类型之前。

```cpp
//正确：inline 说明符跟在模板参数列表之后
template<typename T > inline T min(const T&,const T&);
```

### 编写类型无关的代码
编写泛型代码的两重要原则：
- 模板中的函数参数睡const 的引用
- 函数体中的判断仅使用了<  比较运算

***Best Practices***
模板程序应该尽量减少对实惨类型的要求。

## 模板编译
当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组成代码以及错误何时被检测到。

模板的头文件通常即包括声明也包括定义。

### 大多数编译错误在实例化期间报告
模板直到实例化时才会生成代码。

# 16.1.2 类模板
***类模板是用来生成类的蓝图，与函数模板不同之处是编译器不能为类模板推断模板参数类型。***

### 定义类模板

### 在模板作用域中引用模板类型
### 类模板的成员函数
### 类模板成员函数的实例化

***Note***
 默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。


 ### 类内简化模板类名的使用
 ### 在类外使用类模板名






