
***当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者公式***
模板类一个很好的例子 就是 ***简历模板、身份证***

泛型编程是一种思想。 模板是用来实现泛型编程的一种方式。  
它允许我们编写可以适用于多种数据类型的代码。通过使用泛型，我们可以编写更加通用和灵活的代码，而不需要为每种数据类型编写重复的代码。  （ 不同类型需要处理相同功能） 迭代器，容器，就是比较好的泛型示例   
模板与类的区别

StrBlob 类  
与   
template<T> calss Blob{    
    
}    
不同 我们的模板可以用于更多类型的元素。与标准库容器相同，当使用Blob 时，用户需要指出元素类型。

# 16.1 定义模板 P578
假定我们希望编写一个函数来比较两个值，并指出第一个值是小于，等于还是大于第二个值。在实际中，我们可能像定义多个函数，每个函数比较一种给定类型的值，
```cpp
//如果两个值相等，返回0，如果v1小 返回-1 如果v2 小返回1

int compare(const string &v1,const string &v2){
    if (v1<v2){
        return -1;
    }
     if (v2<v1){
        return 1;
    }
    return 0;
}


int compare(const double &v1,const double &v2){
    if (v1<v2){
        return -1;
    }
     if (v2<v1){
        return 1;
    }
    return 0;
}

```
两个函数唯一的区别是参数的类型不同。

# 16.1 函数模板
```cpp
template<typename T> 
int compare(const T&v2,const T &v2){
    if (v1<v2){
        return -1;
    }
     if (v2<v1){
        return 1;
    }
    return 0;
}


```

### 在模板定义中， 模板参数列表不能为空。
template<typname T,typename T1....>,参数可以是用逗号分隔的多个。  
*模板参数列表的作用很像函数的参数列表。模板参数表示在类或函数中定义用到的类型或值。（值-->具体的类型）*

### 实例化函数模板
当我们调用一个函数模板时，编译器（通常）用函数实惨来为我们推断模板实惨。  
例如：  
```cpp 
 cout<< compare(1,0)<<endl;//T 为int 

 ``` 

 实惨类型是int ，编译器会推断出模板实惨为int,并将它绑定到模板参数T，
 编译器用推断出来的模板参数来为我们实例化一个特定版本的函数。

 ### 模板类型参数 P579
 我们的compare 函数有一个模板类型参数 T，一般来说。我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是。类型参数可以用来指定返回类型。或函数参数类型。以及在函数体捏用于变量声明。或类型转换。
 ```cpp
template <typename T> T foo(T*p){
    T temp=*p;
    //....
    return temp;
}
 ```

 ### 非类型的模板参数
 除了定义类型参数，还可以在模板中定义 非类型参数，一个非类型参数表示一个值而非一个类型。

 比较不同长度的字符串字面量。

 ```cpp
//测试一下下面代码  
template <unsigned N,unsigned M>
int compare(const char (&p1)[N],const char(&p2)[M]){
    return strcmp(p1,p2);
}
//测试 compare 
void 
 ```
 ***Note***
 非类型模板参数的模板实惨必须是常量表达式。

 ### inline 和 constexpr（const express） 的函数模板

 inline 或constexpr 说明符放在模板参数列表之后，返回类型之前。

```cpp
//正确：inline 说明符跟在模板参数列表之后
template<typename T > inline T min(const T&,const T&);
```

### 编写类型无关的代码
编写泛型代码的两重要原则：
- 模板中的函数参数是const 的引用
- 函数体中的判断仅使用了 <  比较运算

***Best Practices***
模板程序应该尽量减少对实惨类型的要求。

## 模板编译
当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组成代码以及错误何时被检测到。

模板的头文件通常即包括声明也包括定义。
# Note
函数模板和类模板成员函数的定义通常放在头文件中。

# 关键概念：模板和头文件
### 模板包含两种名字：
- 不依赖模板参数的名字
- 依赖模板参数的名字
当使用模板时，所有不依赖模板参数的名字都必须是可见的，这是由模板的提供者来保证的。而模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须可见的。
-   用来实例化模板的所有函数、类型以及类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。
-  通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明，模板的用户必须包含模板头文件，以及用来实例化模板的任何类型的头文件。

### 大多数编译错误在实例化期间报告
模板直到实例化时才会生成代码。

# 16.1.2 类模板
***类模板是用来生成类的蓝图，与函数模板不同之处是编译器不能为类模板推断模板参数类型。***

### 定义类模板
### 实例化类模板
将模板参数T的每个实例替换为给定的模板实惨，
### 在模板作用域中引用模板类型（标准库模板）[Blob模板](/CppPrimer-master/ch16/ex16.12.13/Blob.h)
举例： std::shared_ptr<std::vector<T>> data;
### 类模板的成员函数
- 与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板的成员函数被隐式声明为内联函数。
定义在类模板之外的成员函必须以关键字template开始，后跟类模板参数类列表。
举例：
```cpp
template<typename T>
const T& Blob<T>::back() const
{
    check(0,"back on empty Blob");
    return data->back();
}

```
### 类模板成员函数的实例化
 默认情况下，一个类模板的成员函数只有当程序用到时才进行实例化，
 ```cpp
//实例化 Blob<int> 和接受 initializer_list<int>的构造函数
Blob<int> squares={0,1,2,3,4,5};
//实例化Blob<int>::size() const 
for (size_t i=0;i!=squares.size();i++){
    squares[i]=i*i;//实例化Blob<int>::operator[](size_t)
}
 ```
***Note***
 默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。

 ### 在类代码内简化模板类名的使用 
 [类内简化模板类名的使用](/CppPrimer-master/ch16/ex16.12.13/blobptr.h)
```cpp
 //! prefix
    BlobPtr& operator++();
    BlobPtr& operator--();

    //! postfix
    BlobPtr operator ++(int);
    BlobPtr operator --(int);
```
 ### 在类模板外使用类模板名
 - 当我们在类模板外定义成员时，必须记住，我们并不在类的作用域中，直到遇到类名在表示进入类的作用域
```cpp
 template<typename T>
BlobPtr<T> BlobPtr<T>::operator ++(int)
{
    //简化之前的写法 BlobPtr<T> ret=*this; 
    BlobPtr ret = *this;
    ++*this;

    return ret;
}

Note 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。
```
 ### 类模板与友元
 ### 一对一友好关系
 ### 通用和特定的模板友好关系






