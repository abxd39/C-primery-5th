# 3.5.3 指针和数组
尽管能计算得到尾后指针，但这种操作用法极易出错。为了 让指针的使用更为简单，更安全，C++ 11 标准库应用了两个名为begin和end 的函数。（P106）
标准库函数 begin 和end 


# 6.3.3 返回数组指针
因为数组不能被拷贝，所以函数不能返回数组。
返回数组指针的函数形式如下:

Type (*function(parameter_list))[dimension]
auto func(int i)-> int(*)[10];


具体点的例子:
int(*func(int i))[10];

typedef int arr_int[10];

using int arr_int[10];

arr_int* func(int i);


# 6.4 函数重载
const_cast 在重载函数的情景中最有用。（P209）
# 6.5.1 默认实惨
局部变量不能做为默认实惨。
# 6.5.2 内联函数和 constexpr 函数 放在头文件内，内联函数和constexpr 函数可以在程序中多次定义（P215）
# 6.5.3 调试帮助
- assert 预处理红 在头文件 cassert 头文件中，assert 依赖于一个名为NDEBUG 预处理宏.除了用于assert外，NDEBUG编写自己的条件调试代码
__func__ 函数名字符串值
__FILE__ 文件名字符串值
__LINE__ 行号字符串值
__TIME__ 编译时间字符串值
__DATE__ 编译日期字符串值

# 6.7函数指针 (是类型)
想要声明一个指向函数的指针，只需要用指针替换函数名即可
具体的例子如下：
bool lengthCompare(const string &,const string&);
该函数的类型为
bool(const string &,const string&)
该函数的指针类型为
bool(*pf)(const string &,const string&)
返回函数指针的应用场景：
1、动态绑定
2、函数的参数（函数指针为参数）
# 注意事项
返回值：
不能返回局部变量的引用和指针，
不能返回数组和函数
# 7.1.5拷贝，赋值和析构，
对象在几种情况下会被拷贝：
1、变量初始化
2、以值的方式传递参数或返回对象，

使用赋值运算符

# 7.5.4 隐式的类类型转换 

# 14.9.1 类型转换运算符 ————类型转换运算符是类的一种特殊成员函数，
operator type()const;
因为类型转换运算符是隐式执行的，所以无法给这些函数转递实参，也就不能在类型转换运算符的定义中使用任何形参。


# 关键字
explicit 抑制构造函数定义的隐式类型转换。

# 类

需要控制如何初始化，
需要控制拷贝
需要控制赋值
需要控制销毁
------ 需要考虑使用场景
静态成员函数，静态成员变量，单例时需要
# 构造函数
特点：
不能有返回值
explicit 构造函数只能用于直接初始化；（P265）
constexpr 构造函数（P267）
# const 成员函数声明

int func(string s)const 

constexpr 函数的要求 唯一可执行语句就是返回语句。也可以是空语句，

虚表指针，虚函数，纯虚函数，虚函数指针。
# 8.1 IO类
使用IO操作处理string中的字符会很方便。
# 8.1.2 条件状态
由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态，确定一个流对象的状态的最简单方式是将它作为一个条件来使用
``` c++ 
while( cin>>word)
    //ok 读取操作成功
```
# 模板 ————C++语言既有类模板也有函数模板，模板本身不是类也不是函数，相反可以看作为编译器生成类或函数编写的一份说明，
编译器根据模板来创建类或函数的过程称为实例化，当使用模板时需要指出，编译器应把类模板或函数模板实例化成何种类型或函数。
利用模板，我们可以使用具有继承关系的类，而不必了解继承机制的工作细节。